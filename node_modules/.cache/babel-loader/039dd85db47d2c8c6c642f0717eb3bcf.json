{"ast":null,"code":"import React from\"react\";import Layout,{InlineMath,BlockMath,SyntaxHighlighter}from\"../../Layout\";const codeString=\"\\nclass PID:\\n    def __init__(self, Kp, Ki, Kd, setpoint):\\n        self.Kp = Kp\\n        self.Ki = Ki\\n        self.Kd = Kd\\n        self.setpoint = setpoint\\n        self.integral = 0\\n        self.previous_error = 0\\n\\n    def update(self, measured_value, dt):\\n        # Calculate error\\n        error = self.setpoint - measured_value\\n        \\n        # Proportional term\\n        P_out = self.Kp * error\\n        \\n        # Integral term\\n        self.integral += error * dt\\n        I_out = self.Ki * self.integral\\n        \\n        # Derivative term\\n        derivative = (error - self.previous_error) / dt\\n        D_out = self.Kd * derivative\\n        \\n        # Total output\\n        output = P_out + I_out + D_out\\n        \\n        # Save error for next iteration\\n        self.previous_error = error\\n        \\n        return output\\n\\n# Example usage\\nimport time\\n\\n# PID controller with Kp=1.0, Ki=0.1, Kd=0.05, and setpoint=10\\npid = PID(Kp=1.0, Ki=0.1, Kd=0.05, setpoint=10)\\n\\n# Simulate a process variable (e.g., temperature)\\nmeasured_value = 0\\ndt = 0.1  # time step in seconds\\n\\nfor i in range(100):\\n    control_output = pid.update(measured_value, dt)\\n    # Simulate process reaction to control output (for example purposes only)\\n    measured_value += control_output * dt\\n    print(f\\\"Time: {i*dt:.1f}s, Measured Value: {measured_value:.2f}, Control Output: {control_output:.2f}\\\")\\n    time.sleep(dt)\\n  \";function PID(){return/*#__PURE__*/React.createElement(\"main\",null,/*#__PURE__*/React.createElement(\"h2\",null,\"PID Control Explanation\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Proportional-Integral-Derivative Control\"),/*#__PURE__*/React.createElement(\"p\",null,/*#__PURE__*/React.createElement(\"strong\",null,\"Proportional Term (P):\")),/*#__PURE__*/React.createElement(\"ul\",null,/*#__PURE__*/React.createElement(\"li\",null,\"The proportional term produces an output value that is proportional to the current error value.\"),/*#__PURE__*/React.createElement(\"li\",null,\"The proportional response can be adjusted by multiplying the error by a constant \",/*#__PURE__*/React.createElement(InlineMath,{math:\"K_p\"}),\", known as the proportional gain.\"),/*#__PURE__*/React.createElement(\"li\",null,\"If the error is large, the control output is large, and vice versa.\")),/*#__PURE__*/React.createElement(\"p\",null,/*#__PURE__*/React.createElement(\"strong\",null,\"Integral Term (I):\")),/*#__PURE__*/React.createElement(\"ul\",null,/*#__PURE__*/React.createElement(\"li\",null,\"The integral term is concerned with the accumulation of past errors.\"),/*#__PURE__*/React.createElement(\"li\",null,\"If the error has been present for some time, the integral term will accumulate and attempt to correct the error.\"),/*#__PURE__*/React.createElement(\"li\",null,\"This term is multiplied by a constant \",/*#__PURE__*/React.createElement(InlineMath,{math:\"K_i\"}),\", the integral gain.\")),/*#__PURE__*/React.createElement(\"p\",null,/*#__PURE__*/React.createElement(\"strong\",null,\"Derivative Term (D):\")),/*#__PURE__*/React.createElement(\"ul\",null,/*#__PURE__*/React.createElement(\"li\",null,\"The derivative term predicts future error based on its rate of change.\"),/*#__PURE__*/React.createElement(\"li\",null,\"By looking at the rate of change of the error, it applies a damping effect, which reduces the overshoot.\"),/*#__PURE__*/React.createElement(\"li\",null,\"This term is multiplied by a constant \",/*#__PURE__*/React.createElement(InlineMath,{math:\"K_d\"}),\", the derivative gain.\")),/*#__PURE__*/React.createElement(\"h3\",null,\"PID Control Algorithm\"),/*#__PURE__*/React.createElement(\"p\",null,\"The PID control algorithm can be represented as:\"),/*#__PURE__*/React.createElement(BlockMath,{math:\"output(t) = K_p \\\\cdot e(t) + K_i \\\\cdot \\\\int_0^t e(\\\\tau) \\\\, d\\\\tau + K_d \\\\cdot \\\\frac{d e(t)}{d t}\"}),/*#__PURE__*/React.createElement(\"p\",null,\"where:\"),/*#__PURE__*/React.createElement(\"ul\",null,/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(InlineMath,{math:\"e(t)\"}),\" is the error at time \",/*#__PURE__*/React.createElement(InlineMath,{math:\"t\"}),\".\"),/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(InlineMath,{math:\"K_p\"}),\" is the proportional gain.\"),/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(InlineMath,{math:\"K_i\"}),\" is the integral gain.\"),/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(InlineMath,{math:\"K_d\"}),\" is the derivative gain.\")),/*#__PURE__*/React.createElement(\"h3\",null,\"Python Implementation\"),/*#__PURE__*/React.createElement(SyntaxHighlighter,{language:\"python\"},codeString));;}export default PID;","map":{"version":3,"names":["React","Layout","InlineMath","BlockMath","SyntaxHighlighter","codeString","PID","createElement","math","language"],"sources":["/Users/wongdowling/Documents/my_notes/src/subsections/Algorithm/PID.js"],"sourcesContent":["import React from \"react\";\nimport Layout, { InlineMath, BlockMath, SyntaxHighlighter } from \"../../Layout\";\n\nconst codeString = `\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.integral = 0\n        self.previous_error = 0\n\n    def update(self, measured_value, dt):\n        # Calculate error\n        error = self.setpoint - measured_value\n        \n        # Proportional term\n        P_out = self.Kp * error\n        \n        # Integral term\n        self.integral += error * dt\n        I_out = self.Ki * self.integral\n        \n        # Derivative term\n        derivative = (error - self.previous_error) / dt\n        D_out = self.Kd * derivative\n        \n        # Total output\n        output = P_out + I_out + D_out\n        \n        # Save error for next iteration\n        self.previous_error = error\n        \n        return output\n\n# Example usage\nimport time\n\n# PID controller with Kp=1.0, Ki=0.1, Kd=0.05, and setpoint=10\npid = PID(Kp=1.0, Ki=0.1, Kd=0.05, setpoint=10)\n\n# Simulate a process variable (e.g., temperature)\nmeasured_value = 0\ndt = 0.1  # time step in seconds\n\nfor i in range(100):\n    control_output = pid.update(measured_value, dt)\n    # Simulate process reaction to control output (for example purposes only)\n    measured_value += control_output * dt\n    print(f\"Time: {i*dt:.1f}s, Measured Value: {measured_value:.2f}, Control Output: {control_output:.2f}\")\n    time.sleep(dt)\n  `;\n\n  \n\n\nfunction PID() {\n  return (\n    <main>\n      <h2>PID Control Explanation</h2>\n      <h3>Proportional-Integral-Derivative Control</h3>\n      <p>\n        <strong>Proportional Term (P):</strong>\n      </p>\n      <ul>\n        <li>The proportional term produces an output value that is proportional to the current error value.</li>\n        <li>The proportional response can be adjusted by multiplying the error by a constant <InlineMath math=\"K_p\" />, known as the proportional gain.</li>\n        <li>If the error is large, the control output is large, and vice versa.</li>\n      </ul>\n      <p>\n        <strong>Integral Term (I):</strong>\n      </p>\n      <ul>\n        <li>The integral term is concerned with the accumulation of past errors.</li>\n        <li>If the error has been present for some time, the integral term will accumulate and attempt to correct the error.</li>\n        <li>This term is multiplied by a constant <InlineMath math=\"K_i\" />, the integral gain.</li>\n      </ul>\n      <p>\n        <strong>Derivative Term (D):</strong>\n      </p>\n      <ul>\n        <li>The derivative term predicts future error based on its rate of change.</li>\n        <li>By looking at the rate of change of the error, it applies a damping effect, which reduces the overshoot.</li>\n        <li>This term is multiplied by a constant <InlineMath math=\"K_d\" />, the derivative gain.</li>\n      </ul>\n      <h3>PID Control Algorithm</h3>\n      <p>\n        The PID control algorithm can be represented as:\n      </p>\n      <BlockMath math=\"output(t) = K_p \\cdot e(t) + K_i \\cdot \\int_0^t e(\\tau) \\, d\\tau + K_d \\cdot \\frac{d e(t)}{d t}\" />\n      <p>where:</p>\n      <ul>\n        <li><InlineMath math=\"e(t)\" /> is the error at time <InlineMath math=\"t\" />.</li>\n        <li><InlineMath math=\"K_p\" /> is the proportional gain.</li>\n        <li><InlineMath math=\"K_i\" /> is the integral gain.</li>\n        <li><InlineMath math=\"K_d\" /> is the derivative gain.</li>\n      </ul>\n      <h3>Python Implementation</h3>\n      <SyntaxHighlighter language=\"python\" >\n        {codeString}\n      </SyntaxHighlighter>\n    </main>\n  );\n  ;\n}\n\nexport default PID;\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,KAAM,OAAO,CACzB,MAAO,CAAAC,MAAM,EAAIC,UAAU,CAAEC,SAAS,CAAEC,iBAAiB,KAAQ,cAAc,CAE/E,KAAM,CAAAC,UAAU,k6CAiDb,CAKH,QAAS,CAAAC,GAAGA,CAAA,CAAG,CACb,mBACEN,KAAA,CAAAO,aAAA,0BACEP,KAAA,CAAAO,aAAA,WAAI,yBAA2B,CAAC,cAChCP,KAAA,CAAAO,aAAA,WAAI,0CAA4C,CAAC,cACjDP,KAAA,CAAAO,aAAA,uBACEP,KAAA,CAAAO,aAAA,eAAQ,wBAA8B,CACrC,CAAC,cACJP,KAAA,CAAAO,aAAA,wBACEP,KAAA,CAAAO,aAAA,WAAI,iGAAmG,CAAC,cACxGP,KAAA,CAAAO,aAAA,WAAI,mFAAiF,cAAAP,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,KAAK,CAAE,CAAC,oCAAqC,CAAC,cACpJR,KAAA,CAAAO,aAAA,WAAI,qEAAuE,CACzE,CAAC,cACLP,KAAA,CAAAO,aAAA,uBACEP,KAAA,CAAAO,aAAA,eAAQ,oBAA0B,CACjC,CAAC,cACJP,KAAA,CAAAO,aAAA,wBACEP,KAAA,CAAAO,aAAA,WAAI,sEAAwE,CAAC,cAC7EP,KAAA,CAAAO,aAAA,WAAI,kHAAoH,CAAC,cACzHP,KAAA,CAAAO,aAAA,WAAI,wCAAsC,cAAAP,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,KAAK,CAAE,CAAC,uBAAwB,CACzF,CAAC,cACLR,KAAA,CAAAO,aAAA,uBACEP,KAAA,CAAAO,aAAA,eAAQ,sBAA4B,CACnC,CAAC,cACJP,KAAA,CAAAO,aAAA,wBACEP,KAAA,CAAAO,aAAA,WAAI,wEAA0E,CAAC,cAC/EP,KAAA,CAAAO,aAAA,WAAI,0GAA4G,CAAC,cACjHP,KAAA,CAAAO,aAAA,WAAI,wCAAsC,cAAAP,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,KAAK,CAAE,CAAC,yBAA0B,CAC3F,CAAC,cACLR,KAAA,CAAAO,aAAA,WAAI,uBAAyB,CAAC,cAC9BP,KAAA,CAAAO,aAAA,UAAG,kDAEA,CAAC,cACJP,KAAA,CAAAO,aAAA,CAACJ,SAAS,EAACK,IAAI,CAAC,yGAAiG,CAAE,CAAC,cACpHR,KAAA,CAAAO,aAAA,UAAG,QAAS,CAAC,cACbP,KAAA,CAAAO,aAAA,wBACEP,KAAA,CAAAO,aAAA,wBAAIP,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,MAAM,CAAE,CAAC,yBAAsB,cAAAR,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,GAAG,CAAE,CAAC,IAAK,CAAC,cACjFR,KAAA,CAAAO,aAAA,wBAAIP,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,KAAK,CAAE,CAAC,6BAA8B,CAAC,cAC5DR,KAAA,CAAAO,aAAA,wBAAIP,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,KAAK,CAAE,CAAC,yBAA0B,CAAC,cACxDR,KAAA,CAAAO,aAAA,wBAAIP,KAAA,CAAAO,aAAA,CAACL,UAAU,EAACM,IAAI,CAAC,KAAK,CAAE,CAAC,2BAA4B,CACvD,CAAC,cACLR,KAAA,CAAAO,aAAA,WAAI,uBAAyB,CAAC,cAC9BP,KAAA,CAAAO,aAAA,CAACH,iBAAiB,EAACK,QAAQ,CAAC,QAAQ,EACjCJ,UACgB,CACf,CAAC,CAET,CACF,CAEA,cAAe,CAAAC,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module"}