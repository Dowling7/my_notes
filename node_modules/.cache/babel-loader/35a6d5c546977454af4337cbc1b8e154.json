{"ast":null,"code":"'use strict';\n\nvar core = require('@react-pdf-viewer/core');\nvar React = require('react');\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\nvar NextIcon = function () {\n  return React__namespace.createElement(core.Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043\\n            L23.541,5.627\"\n  }));\n};\nvar PreviousIcon = function () {\n  return React__namespace.createElement(core.Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8\\n            L0.535,18.373\"\n  }));\n};\nvar SearchIcon = function () {\n  return React__namespace.createElement(core.Icon, {\n    ignoreDirection: true,\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M10.5,0.5c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.5,10.5,0.5z\\n            M23.5,23.5\\n            l-5.929-5.929\"\n  }));\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar EMPTY_KEYWORD_REGEXP = {\n  keyword: '',\n  regExp: new RegExp(' '),\n  wholeWords: false\n};\nvar calculateOffset = function (children, parent) {\n  var top = children.offsetTop;\n  var left = children.offsetLeft;\n  var p = children.parentElement;\n  while (p && p !== parent) {\n    top += p.offsetTop;\n    left += p.offsetLeft;\n    p = p.parentElement;\n  }\n  return {\n    left: left,\n    top: top\n  };\n};\nvar getCssProperties = function (area) {\n  return {\n    left: \"\".concat(area.left, \"%\"),\n    top: \"\".concat(area.top, \"%\"),\n    height: \"\".concat(area.height, \"%\"),\n    width: \"\".concat(area.width, \"%\")\n  };\n};\nvar HightlightItem = function (_a) {\n  var index = _a.index,\n    area = _a.area,\n    onHighlightKeyword = _a.onHighlightKeyword;\n  var containerRef = React__namespace.useRef();\n  core.useIsomorphicLayoutEffect(function () {\n    var highlightEle = containerRef.current;\n    if (onHighlightKeyword && highlightEle) {\n      onHighlightKeyword({\n        highlightEle: highlightEle,\n        keyword: area.keyword\n      });\n    }\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-search__highlight\",\n    \"data-index\": index,\n    ref: containerRef,\n    style: getCssProperties(area),\n    title: area.keywordStr.trim()\n  });\n};\nvar removeNode = function (ele) {\n  var parent = ele.parentNode;\n  if (parent) {\n    parent.removeChild(ele);\n  }\n};\nvar replaceNode = function (replacementNode, node) {\n  removeNode(replacementNode);\n  var parent = node.parentNode;\n  if (parent) {\n    parent.insertBefore(replacementNode, node);\n  }\n  removeNode(node);\n};\nvar unwrap = function (ele) {\n  var parent = ele.parentNode;\n  if (!parent) {\n    return;\n  }\n  var range = document.createRange();\n  range.selectNodeContents(ele);\n  replaceNode(range.extractContents(), ele);\n  parent.normalize();\n};\nvar sortHighlightPosition = function (a, b) {\n  if (a.top < b.top) {\n    return -1;\n  }\n  if (a.top > b.top) {\n    return 1;\n  }\n  if (a.left < b.left) {\n    return -1;\n  }\n  if (a.left > b.left) {\n    return 1;\n  }\n  return 0;\n};\nvar Highlights = function (_a) {\n  var numPages = _a.numPages,\n    pageIndex = _a.pageIndex,\n    renderHighlights = _a.renderHighlights,\n    store = _a.store,\n    onHighlightKeyword = _a.onHighlightKeyword;\n  var containerRef = React__namespace.useRef();\n  var defaultRenderHighlights = React__namespace.useCallback(function (renderProps) {\n    return React__namespace.createElement(React__namespace.Fragment, null, renderProps.highlightAreas.map(function (area, index) {\n      return React__namespace.createElement(HightlightItem, {\n        index: index,\n        key: index,\n        area: area,\n        onHighlightKeyword: onHighlightKeyword\n      });\n    }));\n  }, []);\n  var renderHighlightElements = renderHighlights || defaultRenderHighlights;\n  var _b = React__namespace.useState(store.get('matchPosition')),\n    matchPosition = _b[0],\n    setMatchPosition = _b[1];\n  var _c = React__namespace.useState(store.get('keyword') || [EMPTY_KEYWORD_REGEXP]),\n    keywordRegexp = _c[0],\n    setKeywordRegexp = _c[1];\n  var _d = React__namespace.useState({\n      pageIndex: pageIndex,\n      scale: 1,\n      status: core.LayerRenderStatus.PreRender\n    }),\n    renderStatus = _d[0],\n    setRenderStatus = _d[1];\n  var currentMatchRef = React__namespace.useRef(null);\n  var characterIndexesRef = React__namespace.useRef([]);\n  var _e = React__namespace.useState([]),\n    highlightAreas = _e[0],\n    setHighlightAreas = _e[1];\n  var defaultTargetPageFilter = function () {\n    return true;\n  };\n  var targetPageFilter = React__namespace.useCallback(function () {\n    return store.get('targetPageFilter') || defaultTargetPageFilter;\n  }, [store.get('targetPageFilter')]);\n  var highlight = function (keywordStr, keyword, textLayerEle, span, charIndexSpan) {\n    var range = document.createRange();\n    var firstChild = span.firstChild;\n    if (!firstChild || firstChild.nodeType !== Node.TEXT_NODE) {\n      return null;\n    }\n    var length = firstChild.textContent.length;\n    var startOffset = charIndexSpan[0].charIndexInSpan;\n    var endOffset = charIndexSpan.length === 1 ? startOffset : charIndexSpan[charIndexSpan.length - 1].charIndexInSpan;\n    if (startOffset > length || endOffset + 1 > length) {\n      return null;\n    }\n    range.setStart(firstChild, startOffset);\n    range.setEnd(firstChild, endOffset + 1);\n    var wrapper = document.createElement('span');\n    range.surroundContents(wrapper);\n    var wrapperRect = wrapper.getBoundingClientRect();\n    var textLayerRect = textLayerEle.getBoundingClientRect();\n    var pageHeight = textLayerRect.height;\n    var pageWidth = textLayerRect.width;\n    var left = 100 * (wrapperRect.left - textLayerRect.left) / pageWidth;\n    var top = 100 * (wrapperRect.top - textLayerRect.top) / pageHeight;\n    var height = 100 * wrapperRect.height / pageHeight;\n    var width = 100 * wrapperRect.width / pageWidth;\n    unwrap(wrapper);\n    return {\n      keyword: keyword,\n      keywordStr: keywordStr,\n      numPages: numPages,\n      pageIndex: pageIndex,\n      left: left,\n      top: top,\n      height: height,\n      width: width,\n      pageHeight: pageHeight,\n      pageWidth: pageWidth\n    };\n  };\n  var highlightAll = function (textLayerEle) {\n    var charIndexes = characterIndexesRef.current;\n    if (charIndexes.length === 0) {\n      return [];\n    }\n    var highlightPos = [];\n    var spans = [].slice.call(textLayerEle.querySelectorAll('.rpv-core__text-layer-text'));\n    var fullText = charIndexes.map(function (item) {\n      return item.char;\n    }).join('');\n    keywordRegexp.forEach(function (keyword) {\n      var keywordStr = keyword.keyword;\n      if (!keywordStr.trim()) {\n        return;\n      }\n      var cloneKeyword = keyword.regExp.flags.indexOf('g') === -1 ? new RegExp(keyword.regExp, \"\".concat(keyword.regExp.flags, \"g\")) : keyword.regExp;\n      var match;\n      var matches = [];\n      while ((match = cloneKeyword.exec(fullText)) !== null) {\n        matches.push({\n          keyword: cloneKeyword,\n          startIndex: match.index,\n          endIndex: cloneKeyword.lastIndex\n        });\n      }\n      matches.map(function (item) {\n        return {\n          keyword: item.keyword,\n          indexes: charIndexes.slice(item.startIndex, item.endIndex)\n        };\n      }).forEach(function (item) {\n        var spanIndexes = item.indexes.reduce(function (acc, item) {\n          acc[item.spanIndex] = (acc[item.spanIndex] || []).concat([item]);\n          return acc;\n        }, {});\n        Object.values(spanIndexes).forEach(function (charIndexSpan) {\n          if (charIndexSpan.length !== 1 || charIndexSpan[0].char.trim() !== '') {\n            var normalizedCharSpan = keyword.wholeWords ? charIndexSpan.slice(1, -1) : charIndexSpan;\n            var hightlighPosition = highlight(keywordStr, item.keyword, textLayerEle, spans[normalizedCharSpan[0].spanIndex], normalizedCharSpan);\n            if (hightlighPosition) {\n              highlightPos.push(hightlighPosition);\n            }\n          }\n        });\n      });\n    });\n    return highlightPos.sort(sortHighlightPosition);\n  };\n  var handleKeywordChanged = function (keyword) {\n    if (keyword && keyword.length > 0) {\n      setKeywordRegexp(keyword);\n    }\n  };\n  var handleMatchPositionChanged = function (currentPosition) {\n    return setMatchPosition(currentPosition);\n  };\n  var handleRenderStatusChanged = function (status) {\n    if (!status.has(pageIndex)) {\n      return;\n    }\n    var currentStatus = status.get(pageIndex);\n    if (currentStatus) {\n      setRenderStatus({\n        ele: currentStatus.ele,\n        pageIndex: pageIndex,\n        scale: currentStatus.scale,\n        status: currentStatus.status\n      });\n    }\n  };\n  var isEmptyKeyword = function () {\n    return keywordRegexp.length === 0 || keywordRegexp.length === 1 && keywordRegexp[0].keyword.trim() === '';\n  };\n  React__namespace.useEffect(function () {\n    if (isEmptyKeyword() || renderStatus.status !== core.LayerRenderStatus.DidRender || characterIndexesRef.current.length) {\n      return;\n    }\n    var textLayerEle = renderStatus.ele;\n    var spans = [].slice.call(textLayerEle.querySelectorAll('.rpv-core__text-layer-text'));\n    var charIndexes = spans.map(function (span) {\n      return span.textContent;\n    }).reduce(function (prev, curr, index) {\n      return prev.concat(curr.split('').map(function (c, i) {\n        return {\n          char: c,\n          charIndexInSpan: i,\n          spanIndex: index\n        };\n      }));\n    }, [{\n      char: '',\n      charIndexInSpan: 0,\n      spanIndex: 0\n    }]).slice(1);\n    characterIndexesRef.current = charIndexes;\n  }, [keywordRegexp, renderStatus.status]);\n  React__namespace.useEffect(function () {\n    if (isEmptyKeyword() || !renderStatus.ele || renderStatus.status !== core.LayerRenderStatus.DidRender || !targetPageFilter()({\n      pageIndex: pageIndex,\n      numPages: numPages\n    })) {\n      return;\n    }\n    var textLayerEle = renderStatus.ele;\n    var highlightPos = highlightAll(textLayerEle);\n    setHighlightAreas(highlightPos);\n  }, [keywordRegexp, matchPosition, renderStatus.status, characterIndexesRef.current]);\n  React__namespace.useEffect(function () {\n    if (isEmptyKeyword() && renderStatus.ele && renderStatus.status === core.LayerRenderStatus.DidRender) {\n      setHighlightAreas([]);\n    }\n  }, [keywordRegexp, renderStatus.status]);\n  React__namespace.useEffect(function () {\n    if (highlightAreas.length === 0) {\n      return;\n    }\n    var container = containerRef.current;\n    if (matchPosition.pageIndex !== pageIndex || !container || renderStatus.status !== core.LayerRenderStatus.DidRender) {\n      return;\n    }\n    var highlightEle = container.querySelector(\".rpv-search__highlight[data-index=\\\"\".concat(matchPosition.matchIndex, \"\\\"]\"));\n    if (!highlightEle) {\n      return;\n    }\n    var _a = calculateOffset(highlightEle, container),\n      left = _a.left,\n      top = _a.top;\n    var jump = store.get('jumpToDestination');\n    if (jump) {\n      jump({\n        pageIndex: pageIndex,\n        bottomOffset: (container.getBoundingClientRect().height - top) / renderStatus.scale,\n        leftOffset: left / renderStatus.scale,\n        scaleTo: renderStatus.scale\n      });\n      if (currentMatchRef.current) {\n        currentMatchRef.current.classList.remove('rpv-search__highlight--current');\n      }\n      currentMatchRef.current = highlightEle;\n      highlightEle.classList.add('rpv-search__highlight--current');\n    }\n  }, [highlightAreas, matchPosition]);\n  React__namespace.useEffect(function () {\n    store.subscribe('keyword', handleKeywordChanged);\n    store.subscribe('matchPosition', handleMatchPositionChanged);\n    store.subscribe('renderStatus', handleRenderStatusChanged);\n    return function () {\n      store.unsubscribe('keyword', handleKeywordChanged);\n      store.unsubscribe('matchPosition', handleMatchPositionChanged);\n      store.unsubscribe('renderStatus', handleRenderStatusChanged);\n    };\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-search__highlights\",\n    \"data-testid\": \"search__highlights-\".concat(pageIndex),\n    ref: containerRef\n  }, renderHighlightElements({\n    getCssProperties: getCssProperties,\n    highlightAreas: highlightAreas\n  }));\n};\nvar escapeRegExp = function (input) {\n  return input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\nvar normalizeFlagKeyword = function (flagKeyword) {\n  var source = flagKeyword.wholeWords ? \" \".concat(flagKeyword.keyword, \" \") : flagKeyword.keyword;\n  var flags = flagKeyword.matchCase ? 'g' : 'gi';\n  return {\n    keyword: flagKeyword.keyword,\n    regExp: new RegExp(escapeRegExp(source), flags),\n    wholeWords: flagKeyword.wholeWords || false\n  };\n};\nvar normalizeSingleKeyword = function (keyword, matchCase, wholeWords) {\n  if (keyword instanceof RegExp) {\n    return {\n      keyword: keyword.source,\n      regExp: keyword,\n      wholeWords: wholeWords || false\n    };\n  }\n  if (typeof keyword === 'string') {\n    return keyword === '' ? EMPTY_KEYWORD_REGEXP : normalizeFlagKeyword({\n      keyword: keyword,\n      matchCase: matchCase || false,\n      wholeWords: wholeWords || false\n    });\n  }\n  if (typeof matchCase !== 'undefined') {\n    keyword.matchCase = matchCase;\n  }\n  if (typeof wholeWords !== 'undefined') {\n    keyword.wholeWords = wholeWords;\n  }\n  return normalizeFlagKeyword(keyword);\n};\nvar useDocument = function (store) {\n  var currentDocRef = React__namespace.useRef(store.get('doc'));\n  var handleDocumentChanged = function (doc) {\n    currentDocRef.current = doc;\n  };\n  React__namespace.useEffect(function () {\n    store.subscribe('doc', handleDocumentChanged);\n    return function () {\n      store.unsubscribe('doc', handleDocumentChanged);\n    };\n  }, []);\n  return currentDocRef;\n};\nvar useSearch = function (store) {\n  var initialKeyword = store.get('initialKeyword');\n  var normalizedKeywordFlags = React__namespace.useMemo(function () {\n    if (initialKeyword && initialKeyword.length === 1) {\n      var normalizedKeyword = normalizeSingleKeyword(initialKeyword[0]);\n      return {\n        matchCase: normalizedKeyword.regExp.flags.indexOf('i') === -1,\n        wholeWords: normalizedKeyword.wholeWords\n      };\n    } else {\n      return {\n        matchCase: false,\n        wholeWords: false\n      };\n    }\n  }, []);\n  var currentDocRef = useDocument(store);\n  var _a = React__namespace.useState(initialKeyword),\n    keywords = _a[0],\n    setKeywords = _a[1];\n  var _b = React__namespace.useState([]),\n    found = _b[0],\n    setFound = _b[1];\n  var _c = React__namespace.useState(0),\n    currentMatch = _c[0],\n    setCurrentMatch = _c[1];\n  var _d = React__namespace.useState(normalizedKeywordFlags.matchCase),\n    matchCase = _d[0],\n    setMatchCase = _d[1];\n  var textContents = React__namespace.useRef([]);\n  var _e = React__namespace.useState(normalizedKeywordFlags.wholeWords),\n    wholeWords = _e[0],\n    setWholeWords = _e[1];\n  var defaultTargetPageFilter = function () {\n    return true;\n  };\n  var targetPageFilter = React__namespace.useCallback(function () {\n    return store.get('targetPageFilter') || defaultTargetPageFilter;\n  }, [store.get('targetPageFilter')]);\n  var changeMatchCase = function (isChecked) {\n    setMatchCase(isChecked);\n    if (keywords.length > 0) {\n      searchFor(keywords, isChecked, wholeWords);\n    }\n  };\n  var changeWholeWords = function (isChecked) {\n    setWholeWords(isChecked);\n    if (keywords.length > 0) {\n      searchFor(keywords, matchCase, isChecked);\n    }\n  };\n  var jumpToMatch = function (index) {\n    var numMatches = found.length;\n    if (keywords.length === 0 || numMatches === 0) {\n      return null;\n    }\n    var normalizedIndex = index === numMatches + 1 ? 1 : Math.max(1, Math.min(numMatches, index));\n    setCurrentMatch(normalizedIndex);\n    return jumpToGivenMatch(found[normalizedIndex - 1]);\n  };\n  var jumpToPreviousMatch = function () {\n    return jumpToMatch(currentMatch - 1);\n  };\n  var jumpToNextMatch = function () {\n    return jumpToMatch(currentMatch + 1);\n  };\n  var clearKeyword = function () {\n    store.update('keyword', [EMPTY_KEYWORD_REGEXP]);\n    setKeyword('');\n    setCurrentMatch(0);\n    setFound([]);\n    setMatchCase(false);\n    setWholeWords(false);\n  };\n  var search = function () {\n    return searchFor(keywords, matchCase, wholeWords);\n  };\n  var setKeyword = function (keyword) {\n    return setKeywords(keyword === '' ? [] : [keyword]);\n  };\n  var setTargetPages = function (targetPageFilter) {\n    store.update('targetPageFilter', targetPageFilter);\n  };\n  var getTextContents = function () {\n    var currentDoc = currentDocRef.current;\n    if (!currentDoc) {\n      return Promise.resolve([]);\n    }\n    var promises = Array(currentDoc.numPages).fill(0).map(function (_, pageIndex) {\n      return core.getPage(currentDoc, pageIndex).then(function (page) {\n        return page.getTextContent();\n      }).then(function (content) {\n        var pageContent = content.items.map(function (item) {\n          return item.str || '';\n        }).join('');\n        return Promise.resolve({\n          pageContent: pageContent,\n          pageIndex: pageIndex\n        });\n      });\n    });\n    return Promise.all(promises).then(function (data) {\n      data.sort(function (a, b) {\n        return a.pageIndex - b.pageIndex;\n      });\n      return Promise.resolve(data.map(function (item) {\n        return item.pageContent;\n      }));\n    });\n  };\n  var jumpToGivenMatch = function (match) {\n    var jumpToPage = store.get('jumpToPage');\n    if (jumpToPage) {\n      jumpToPage(match.pageIndex);\n    }\n    store.update('matchPosition', {\n      matchIndex: match.matchIndex,\n      pageIndex: match.pageIndex\n    });\n    return match;\n  };\n  var getKeywordSource = function (keyword) {\n    if (keyword instanceof RegExp) {\n      return keyword.source;\n    }\n    if (typeof keyword === 'string') {\n      return keyword;\n    }\n    return keyword.keyword;\n  };\n  var searchFor = function (keywordParam, matchCaseParam, wholeWordsParam) {\n    var currentDoc = currentDocRef.current;\n    if (!currentDoc) {\n      return Promise.resolve([]);\n    }\n    var numPages = currentDoc.numPages;\n    var keywords = keywordParam.map(function (k) {\n      return normalizeSingleKeyword(k, matchCaseParam, wholeWordsParam);\n    });\n    store.update('keyword', keywords);\n    setCurrentMatch(0);\n    setFound([]);\n    return new Promise(function (resolve, _) {\n      var getTextPromise = textContents.current.length === 0 ? getTextContents().then(function (response) {\n        textContents.current = response;\n        return Promise.resolve(response);\n      }) : Promise.resolve(textContents.current);\n      getTextPromise.then(function (response) {\n        var arr = [];\n        response.forEach(function (pageText, pageIndex) {\n          if (targetPageFilter()({\n            pageIndex: pageIndex,\n            numPages: numPages\n          })) {\n            keywords.forEach(function (keyword) {\n              var matchIndex = 0;\n              var matches;\n              while ((matches = keyword.regExp.exec(pageText)) !== null) {\n                arr.push({\n                  keyword: keyword.regExp,\n                  matchIndex: matchIndex,\n                  pageIndex: pageIndex,\n                  pageText: pageText,\n                  startIndex: matches.index,\n                  endIndex: keyword.regExp.lastIndex\n                });\n                matchIndex++;\n              }\n            });\n          }\n        });\n        setFound(arr);\n        if (arr.length > 0) {\n          setCurrentMatch(1);\n          jumpToGivenMatch(arr[0]);\n        }\n        resolve(arr);\n      });\n    });\n  };\n  React__namespace.useEffect(function () {\n    textContents.current = [];\n  }, [currentDocRef.current]);\n  return {\n    clearKeyword: clearKeyword,\n    changeMatchCase: changeMatchCase,\n    changeWholeWords: changeWholeWords,\n    currentMatch: currentMatch,\n    jumpToMatch: jumpToMatch,\n    jumpToNextMatch: jumpToNextMatch,\n    jumpToPreviousMatch: jumpToPreviousMatch,\n    keywords: keywords,\n    matchCase: matchCase,\n    numberOfMatches: found.length,\n    wholeWords: wholeWords,\n    search: search,\n    searchFor: searchFor,\n    setKeywords: setKeywords,\n    keyword: keywords.length === 0 ? '' : getKeywordSource(keywords[0]),\n    setKeyword: setKeyword,\n    setTargetPages: setTargetPages\n  };\n};\nvar Search = function (_a) {\n  var children = _a.children,\n    store = _a.store;\n  var result = useSearch(store);\n  var _b = React__namespace.useState(false),\n    isDocumentLoaded = _b[0],\n    setDocumentLoaded = _b[1];\n  var handleDocumentChanged = function (_) {\n    return setDocumentLoaded(true);\n  };\n  React__namespace.useEffect(function () {\n    store.subscribe('doc', handleDocumentChanged);\n    return function () {\n      store.unsubscribe('doc', handleDocumentChanged);\n    };\n  }, []);\n  return children(__assign(__assign({}, result), {\n    isDocumentLoaded: isDocumentLoaded\n  }));\n};\nvar ShortcutHandler = function (_a) {\n  var containerRef = _a.containerRef,\n    store = _a.store;\n  var isMouseInsideRef = React__namespace.useRef(false);\n  var handleMouseEnter = function () {\n    isMouseInsideRef.current = true;\n  };\n  var handleMouseLeave = function () {\n    isMouseInsideRef.current = false;\n  };\n  var handleKeydown = function (e) {\n    var containerEle = containerRef.current;\n    if (!containerEle) {\n      return;\n    }\n    if (e.shiftKey || e.altKey || e.key !== 'f') {\n      return;\n    }\n    var isCommandPressed = core.isMac() ? e.metaKey && !e.ctrlKey : e.ctrlKey;\n    if (!isCommandPressed) {\n      return;\n    }\n    if (isMouseInsideRef.current || document.activeElement && containerEle.contains(document.activeElement)) {\n      e.preventDefault();\n      store.update('areShortcutsPressed', true);\n    }\n  };\n  React__namespace.useEffect(function () {\n    var containerEle = containerRef.current;\n    if (!containerEle) {\n      return;\n    }\n    document.addEventListener('keydown', handleKeydown);\n    containerEle.addEventListener('mouseenter', handleMouseEnter);\n    containerEle.addEventListener('mouseleave', handleMouseLeave);\n    return function () {\n      document.removeEventListener('keydown', handleKeydown);\n      containerEle.removeEventListener('mouseenter', handleMouseEnter);\n      containerEle.removeEventListener('mouseleave', handleMouseLeave);\n    };\n  }, [containerRef.current]);\n  return React__namespace.createElement(React__namespace.Fragment, null);\n};\nvar PORTAL_OFFSET$1 = {\n  left: 0,\n  top: 8\n};\nvar SearchPopover = function (_a) {\n  var store = _a.store,\n    onToggle = _a.onToggle;\n  var l10n = React__namespace.useContext(core.LocalizationContext).l10n;\n  var direction = React__namespace.useContext(core.ThemeContext).direction;\n  var _b = React__namespace.useState(false),\n    isQuerying = _b[0],\n    setIsQuerying = _b[1];\n  var _c = React__namespace.useState(false),\n    searchDone = _c[0],\n    setSearchDone = _c[1];\n  var isRtl = direction === core.TextDirection.RightToLeft;\n  var _d = useSearch(store),\n    clearKeyword = _d.clearKeyword,\n    changeMatchCase = _d.changeMatchCase,\n    changeWholeWords = _d.changeWholeWords,\n    currentMatch = _d.currentMatch,\n    jumpToNextMatch = _d.jumpToNextMatch,\n    jumpToPreviousMatch = _d.jumpToPreviousMatch,\n    keyword = _d.keyword,\n    matchCase = _d.matchCase,\n    numberOfMatches = _d.numberOfMatches,\n    wholeWords = _d.wholeWords,\n    search = _d.search,\n    setKeyword = _d.setKeyword;\n  var performSearch = function (cb) {\n    setIsQuerying(true);\n    search().then(function (_) {\n      setIsQuerying(false);\n      setSearchDone(true);\n      cb && cb();\n    });\n  };\n  var onKeydownSearch = function (e) {\n    if (e.key === 'Enter' && keyword) {\n      searchDone ? jumpToNextMatch() : performSearch();\n    }\n  };\n  var onChangeMatchCase = function (e) {\n    setSearchDone(false);\n    changeMatchCase(e.target.checked);\n  };\n  var onChangeWholeWords = function (e) {\n    setSearchDone(false);\n    changeWholeWords(e.target.checked);\n  };\n  var onClose = function () {\n    onToggle();\n    clearKeyword();\n  };\n  var onChangeKeyword = function (value) {\n    setSearchDone(false);\n    setKeyword(value);\n  };\n  React__namespace.useEffect(function () {\n    var initialKeyword = store.get('initialKeyword');\n    if (initialKeyword && initialKeyword.length === 1 && keyword) {\n      performSearch(function () {\n        store.update('initialKeyword', []);\n      });\n    }\n  }, []);\n  var searchLabel = l10n && l10n.search ? l10n.search.enterToSearch : 'Enter to search';\n  var previousMatchLabel = l10n && l10n.search ? l10n.search.previousMatch : 'Previous match';\n  var nextMatchLabel = l10n && l10n.search ? l10n.search.nextMatch : 'Next match';\n  var closeButtonLabel = l10n && l10n.search ? l10n.search.close : 'Close';\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-search__popover\"\n  }, React__namespace.createElement(\"div\", {\n    className: \"rpv-search__popover-input-counter\"\n  }, React__namespace.createElement(core.TextBox, {\n    ariaLabel: searchLabel,\n    autoFocus: true,\n    placeholder: searchLabel,\n    type: \"text\",\n    value: keyword,\n    onChange: onChangeKeyword,\n    onKeyDown: onKeydownSearch\n  }), React__namespace.createElement(\"div\", {\n    className: core.classNames({\n      'rpv-search__popover-counter': true,\n      'rpv-search__popover-counter--ltr': !isRtl,\n      'rpv-search__popover-counter--rtl': isRtl\n    })\n  }, isQuerying && React__namespace.createElement(core.Spinner, {\n    testId: \"search__popover-searching\",\n    size: \"1rem\"\n  }), !isQuerying && React__namespace.createElement(\"span\", {\n    \"data-testid\": \"search__popover-num-matches\"\n  }, currentMatch, \"/\", numberOfMatches))), React__namespace.createElement(\"label\", {\n    className: \"rpv-search__popover-label\"\n  }, React__namespace.createElement(\"input\", {\n    className: \"rpv-search__popover-label-checkbox\",\n    \"data-testid\": \"search__popover-match-case\",\n    checked: matchCase,\n    type: \"checkbox\",\n    onChange: onChangeMatchCase\n  }), ' ', l10n && l10n.search ? l10n.search.matchCase : 'Match case'), React__namespace.createElement(\"label\", {\n    className: \"rpv-search__popover-label\"\n  }, React__namespace.createElement(\"input\", {\n    className: \"rpv-search__popover-label-checkbox\",\n    checked: wholeWords,\n    \"data-testid\": \"search__popover-whole-words\",\n    type: \"checkbox\",\n    onChange: onChangeWholeWords\n  }), ' ', l10n && l10n.search ? l10n.search.wholeWords : 'Whole words'), React__namespace.createElement(\"div\", {\n    className: \"rpv-search__popover-footer\"\n  }, React__namespace.createElement(\"div\", {\n    className: \"rpv-search__popover-footer-item\"\n  }, React__namespace.createElement(core.Tooltip, {\n    ariaControlsSuffix: \"search-previous-match\",\n    position: isRtl ? core.Position.BottomRight : core.Position.BottomCenter,\n    target: React__namespace.createElement(core.MinimalButton, {\n      ariaLabel: previousMatchLabel,\n      isDisabled: currentMatch <= 1,\n      onClick: jumpToPreviousMatch\n    }, React__namespace.createElement(PreviousIcon, null)),\n    content: function () {\n      return previousMatchLabel;\n    },\n    offset: PORTAL_OFFSET$1\n  })), React__namespace.createElement(\"div\", {\n    className: \"rpv-search__popover-footer-item\"\n  }, React__namespace.createElement(core.Tooltip, {\n    ariaControlsSuffix: \"search-next-match\",\n    position: core.Position.BottomCenter,\n    target: React__namespace.createElement(core.MinimalButton, {\n      ariaLabel: nextMatchLabel,\n      isDisabled: currentMatch > numberOfMatches - 1,\n      onClick: jumpToNextMatch\n    }, React__namespace.createElement(NextIcon, null)),\n    content: function () {\n      return nextMatchLabel;\n    },\n    offset: PORTAL_OFFSET$1\n  })), React__namespace.createElement(\"div\", {\n    className: core.classNames({\n      'rpv-search__popover-footer-button': true,\n      'rpv-search__popover-footer-button--ltr': !isRtl,\n      'rpv-search__popover-footer-button--rtl': isRtl\n    })\n  }, React__namespace.createElement(core.Button, {\n    onClick: onClose\n  }, closeButtonLabel))));\n};\nvar ShowSearchPopoverDecorator = function (_a) {\n  var children = _a.children,\n    onClick = _a.onClick;\n  var l10n = React__namespace.useContext(core.LocalizationContext).l10n;\n  var label = l10n && l10n.search ? l10n.search.search : 'Search';\n  var icon = React__namespace.createElement(SearchIcon, null);\n  return children({\n    icon: icon,\n    label: label,\n    onClick: onClick\n  });\n};\nvar TOOLTIP_OFFSET = {\n  left: 0,\n  top: 8\n};\nvar ShowSearchPopoverButton = function (_a) {\n  var enableShortcuts = _a.enableShortcuts,\n    store = _a.store,\n    onClick = _a.onClick;\n  var ariaKeyShortcuts = enableShortcuts ? core.isMac() ? 'Meta+F' : 'Ctrl+F' : '';\n  var handleShortcutsPressed = function (areShortcutsPressed) {\n    if (areShortcutsPressed) {\n      onClick();\n    }\n  };\n  React__namespace.useEffect(function () {\n    store.subscribe('areShortcutsPressed', handleShortcutsPressed);\n    return function () {\n      store.unsubscribe('areShortcutsPressed', handleShortcutsPressed);\n    };\n  }, []);\n  return React__namespace.createElement(ShowSearchPopoverDecorator, {\n    onClick: onClick\n  }, function (p) {\n    return React__namespace.createElement(core.Tooltip, {\n      ariaControlsSuffix: \"search-popover\",\n      position: core.Position.BottomCenter,\n      target: React__namespace.createElement(core.MinimalButton, {\n        ariaKeyShortcuts: ariaKeyShortcuts,\n        ariaLabel: p.label,\n        testId: \"search__popover-button\",\n        onClick: onClick\n      }, p.icon),\n      content: function () {\n        return p.label;\n      },\n      offset: TOOLTIP_OFFSET\n    });\n  });\n};\nvar PORTAL_OFFSET = {\n  left: 0,\n  top: 8\n};\nvar ShowSearchPopover = function (_a) {\n  var children = _a.children,\n    enableShortcuts = _a.enableShortcuts,\n    store = _a.store;\n  var direction = React__namespace.useContext(core.ThemeContext).direction;\n  var portalPosition = direction === core.TextDirection.RightToLeft ? core.Position.BottomRight : core.Position.BottomLeft;\n  var defaultChildren = function (props) {\n    return React__namespace.createElement(ShowSearchPopoverButton, __assign({\n      enableShortcuts: enableShortcuts,\n      store: store\n    }, props));\n  };\n  var render = children || defaultChildren;\n  return React__namespace.createElement(core.Popover, {\n    ariaControlsSuffix: \"search\",\n    lockScroll: false,\n    position: portalPosition,\n    target: function (toggle) {\n      return render({\n        onClick: toggle\n      });\n    },\n    content: function (toggle) {\n      return React__namespace.createElement(SearchPopover, {\n        store: store,\n        onToggle: toggle\n      });\n    },\n    offset: PORTAL_OFFSET,\n    closeOnClickOutside: false,\n    closeOnEscape: true\n  });\n};\nvar normalizeKeywords = function (keyword) {\n  return Array.isArray(keyword) ? keyword.map(function (k) {\n    return normalizeSingleKeyword(k);\n  }) : [normalizeSingleKeyword(keyword)];\n};\nvar searchPlugin = function (props) {\n  var searchPluginProps = React__namespace.useMemo(function () {\n    return Object.assign({}, {\n      enableShortcuts: true,\n      onHighlightKeyword: function () {}\n    }, props);\n  }, []);\n  var store = React__namespace.useMemo(function () {\n    return core.createStore({\n      initialKeyword: props && props.keyword ? Array.isArray(props.keyword) ? props.keyword : [props.keyword] : [],\n      keyword: props && props.keyword ? normalizeKeywords(props.keyword) : [EMPTY_KEYWORD_REGEXP],\n      matchPosition: {\n        matchIndex: -1,\n        pageIndex: -1\n      },\n      renderStatus: new Map()\n    });\n  }, []);\n  var _a = useSearch(store),\n    clearKeyword = _a.clearKeyword,\n    jumpToMatch = _a.jumpToMatch,\n    jumpToNextMatch = _a.jumpToNextMatch,\n    jumpToPreviousMatch = _a.jumpToPreviousMatch,\n    searchFor = _a.searchFor,\n    setKeywords = _a.setKeywords,\n    setTargetPages = _a.setTargetPages;\n  var SearchDecorator = function (props) {\n    return React__namespace.createElement(Search, __assign({}, props, {\n      store: store\n    }));\n  };\n  var ShowSearchPopoverDecorator = function (props) {\n    return React__namespace.createElement(ShowSearchPopover, __assign({\n      enableShortcuts: searchPluginProps.enableShortcuts\n    }, props, {\n      store: store\n    }));\n  };\n  var ShowSearchPopoverButtonDecorator = function () {\n    return React__namespace.createElement(ShowSearchPopoverDecorator, null, function (props) {\n      return React__namespace.createElement(ShowSearchPopoverButton, __assign({\n        enableShortcuts: searchPluginProps.enableShortcuts,\n        store: store\n      }, props));\n    });\n  };\n  var renderViewer = function (renderViewerProps) {\n    var currentSlot = renderViewerProps.slot;\n    if (currentSlot.subSlot) {\n      currentSlot.subSlot.children = React__namespace.createElement(React__namespace.Fragment, null, searchPluginProps.enableShortcuts && React__namespace.createElement(ShortcutHandler, {\n        containerRef: renderViewerProps.containerRef,\n        store: store\n      }), currentSlot.subSlot.children);\n    }\n    return currentSlot;\n  };\n  var renderPageLayer = function (renderProps) {\n    return React__namespace.createElement(Highlights, {\n      key: renderProps.pageIndex,\n      numPages: renderProps.doc.numPages,\n      pageIndex: renderProps.pageIndex,\n      renderHighlights: props === null || props === void 0 ? void 0 : props.renderHighlights,\n      store: store,\n      onHighlightKeyword: searchPluginProps.onHighlightKeyword\n    });\n  };\n  return {\n    install: function (pluginFunctions) {\n      var initialKeyword = props && props.keyword ? Array.isArray(props.keyword) ? props.keyword : [props.keyword] : [];\n      var keyword = props && props.keyword ? normalizeKeywords(props.keyword) : [EMPTY_KEYWORD_REGEXP];\n      store.update('initialKeyword', initialKeyword);\n      store.update('jumpToDestination', pluginFunctions.jumpToDestination);\n      store.update('jumpToPage', pluginFunctions.jumpToPage);\n      store.update('keyword', keyword);\n    },\n    renderPageLayer: renderPageLayer,\n    renderViewer: renderViewer,\n    uninstall: function (props) {\n      var renderStatus = store.get('renderStatus');\n      if (renderStatus) {\n        renderStatus.clear();\n      }\n    },\n    onDocumentLoad: function (props) {\n      store.update('doc', props.doc);\n    },\n    onTextLayerRender: function (props) {\n      var renderStatus = store.get('renderStatus');\n      if (renderStatus) {\n        renderStatus = renderStatus.set(props.pageIndex, props);\n        store.update('renderStatus', renderStatus);\n      }\n    },\n    Search: SearchDecorator,\n    ShowSearchPopover: ShowSearchPopoverDecorator,\n    ShowSearchPopoverButton: ShowSearchPopoverButtonDecorator,\n    clearHighlights: function () {\n      clearKeyword();\n    },\n    highlight: function (keyword) {\n      var keywords = Array.isArray(keyword) ? keyword : [keyword];\n      setKeywords(keywords);\n      return searchFor(keywords);\n    },\n    jumpToMatch: jumpToMatch,\n    jumpToNextMatch: jumpToNextMatch,\n    jumpToPreviousMatch: jumpToPreviousMatch,\n    setTargetPages: setTargetPages\n  };\n};\nexports.NextIcon = NextIcon;\nexports.PreviousIcon = PreviousIcon;\nexports.SearchIcon = SearchIcon;\nexports.searchPlugin = searchPlugin;","map":null,"metadata":{},"sourceType":"script"}