{"ast":null,"code":"import React from \"react\";\nimport Layout, { InlineMath, BlockMath, SyntaxHighlighter } from \"../../Layout\";\nconst codeString = `\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.integral = 0\n        self.previous_error = 0\n\n    def update(self, measured_value, dt):\n        # Calculate error\n        error = self.setpoint - measured_value\n        \n        # Proportional term\n        P_out = self.Kp * error\n        \n        # Integral term\n        self.integral += error * dt\n        I_out = self.Ki * self.integral\n        \n        # Derivative term\n        derivative = (error - self.previous_error) / dt\n        D_out = self.Kd * derivative\n        \n        # Total output\n        output = P_out + I_out + D_out\n        \n        # Save error for next iteration\n        self.previous_error = error\n        \n        return output\n\n# Example usage\nimport time\n\n# PID controller with Kp=1.0, Ki=0.1, Kd=0.05, and setpoint=10\npid = PID(Kp=1.0, Ki=0.1, Kd=0.05, setpoint=10)\n\n# Simulate a process variable (e.g., temperature)\nmeasured_value = 0\ndt = 0.1  # time step in seconds\n\nfor i in range(100):\n    control_output = pid.update(measured_value, dt)\n    # Simulate process reaction to control output (for example purposes only)\n    measured_value += control_output * dt\n    print(f\"Time: {i*dt:.1f}s, Measured Value: {measured_value:.2f}, Control Output: {control_output:.2f}\")\n    time.sleep(dt)\n  `;\nfunction PID() {\n  return;\n}\nexport default PID;","map":{"version":3,"names":["React","Layout","InlineMath","BlockMath","SyntaxHighlighter","codeString","PID"],"sources":["/Users/wongdowling/Documents/my_notes/src/subsections/Algorithm/PID.js"],"sourcesContent":["import React from \"react\";\nimport Layout, { InlineMath, BlockMath, SyntaxHighlighter } from \"../../Layout\";\n\nconst codeString = `\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.integral = 0\n        self.previous_error = 0\n\n    def update(self, measured_value, dt):\n        # Calculate error\n        error = self.setpoint - measured_value\n        \n        # Proportional term\n        P_out = self.Kp * error\n        \n        # Integral term\n        self.integral += error * dt\n        I_out = self.Ki * self.integral\n        \n        # Derivative term\n        derivative = (error - self.previous_error) / dt\n        D_out = self.Kd * derivative\n        \n        # Total output\n        output = P_out + I_out + D_out\n        \n        # Save error for next iteration\n        self.previous_error = error\n        \n        return output\n\n# Example usage\nimport time\n\n# PID controller with Kp=1.0, Ki=0.1, Kd=0.05, and setpoint=10\npid = PID(Kp=1.0, Ki=0.1, Kd=0.05, setpoint=10)\n\n# Simulate a process variable (e.g., temperature)\nmeasured_value = 0\ndt = 0.1  # time step in seconds\n\nfor i in range(100):\n    control_output = pid.update(measured_value, dt)\n    # Simulate process reaction to control output (for example purposes only)\n    measured_value += control_output * dt\n    print(f\"Time: {i*dt:.1f}s, Measured Value: {measured_value:.2f}, Control Output: {control_output:.2f}\")\n    time.sleep(dt)\n  `;\n\n  \n\n\nfunction PID() {\n  return \n  ;\n}\n\nexport default PID;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,MAAM,IAAIC,UAAU,EAAEC,SAAS,EAAEC,iBAAiB,QAAQ,cAAc;AAE/E,MAAMC,UAAU,GAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AAKH,SAASC,GAAGA,CAAA,EAAG;EACb;AAEF;AAEA,eAAeA,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module"}