{"ast":null,"code":"(function (global, factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") factory(exports, require(\"react\"), require(\"prop-types\"), require(\"katex\"));else if (typeof define === \"function\" && define.amd) define([\"exports\", \"react\", \"prop-types\", \"katex\"], factory);else if (global = typeof globalThis !== \"undefined\" ? globalThis : global || self) factory(global.index = {}, global.react, global.propTypes, global.katex);\n})(this, function (exports, _react, _propTypes, _katex) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  function _export(target, all) {\n    for (var name in all) Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n  _export(exports, {\n    BlockMath: () => BlockMath,\n    InlineMath: () => InlineMath\n  });\n  _react = /*#__PURE__*/_interopRequireWildcard(_react);\n  _propTypes = /*#__PURE__*/_interopRequireDefault(_propTypes);\n  _katex = /*#__PURE__*/_interopRequireDefault(_katex);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n  function _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function (nodeInterop) {\n      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n  }\n  function _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n      return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n      return {\n        default: obj\n      };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n  /**\n  * @typedef {import(\"react\").ReactNode} ReactNode\n  *\n  *\n  * @callback ErrorRenderer\n  * @param {Error} error\n  * @returns {ReactNode}\n  *\n  *\n  * @typedef {object} MathComponentPropsWithMath\n  * @property {string} math\n  * @property {ReactNode=} children\n  * @property {string=} errorColor\n  * @property {ErrorRenderer=} renderError\n  *\n  *\n  * @typedef {object} MathComponentPropsWithChildren\n  * @property {string=} math\n  * @property {ReactNode} children\n  * @property {string=} errorColor\n  * @property {ErrorRenderer=} renderError\n  *\n  * @typedef {MathComponentPropsWithMath | MathComponentPropsWithChildren} MathComponentProps\n  */\n  const createMathComponent = (Component, {\n    displayMode\n  }) => {\n    /**\n    *\n    * @param {MathComponentProps} props\n    * @returns {ReactNode}\n    */\n    const MathComponent = ({\n      children,\n      errorColor,\n      math,\n      renderError\n    }) => {\n      const formula = math !== null && math !== void 0 ? math : children;\n      const {\n        html,\n        error\n      } = (0, _react.useMemo)(() => {\n        try {\n          const html = _katex.default.renderToString(formula, {\n            displayMode,\n            errorColor,\n            throwOnError: !!renderError\n          });\n          return {\n            html,\n            error: undefined\n          };\n        } catch (error) {\n          if (error instanceof _katex.default.ParseError || error instanceof TypeError) {\n            return {\n              error\n            };\n          }\n          throw error;\n        }\n      }, [formula, errorColor, renderError]);\n      if (error) {\n        return renderError ? renderError(error) : /*#__PURE__*/_react.default.createElement(Component, {\n          html: `${error.message}`\n        });\n      }\n      return /*#__PURE__*/_react.default.createElement(Component, {\n        html: html\n      });\n    };\n    MathComponent.propTypes = {\n      children: _propTypes.default.string,\n      errorColor: _propTypes.default.string,\n      math: _propTypes.default.string,\n      renderError: _propTypes.default.func\n    };\n    return MathComponent;\n  };\n  const InternalPathComponentPropTypes = {\n    html: _propTypes.default.string.isRequired\n  };\n  const InternalBlockMath = ({\n    html\n  }) => {\n    return /*#__PURE__*/_react.default.createElement(\"div\", {\n      \"data-testid\": \"react-katex\",\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    });\n  };\n  InternalBlockMath.propTypes = InternalPathComponentPropTypes;\n  const InternalInlineMath = ({\n    html\n  }) => {\n    return /*#__PURE__*/_react.default.createElement(\"span\", {\n      \"data-testid\": \"react-katex\",\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    });\n  };\n  InternalInlineMath.propTypes = InternalPathComponentPropTypes;\n  const BlockMath = createMathComponent(InternalBlockMath, {\n    displayMode: true\n  });\n  const InlineMath = createMathComponent(InternalInlineMath, {\n    displayMode: false\n  });\n});\n\n//# sourceMappingURL=react-katex.js.map","map":null,"metadata":{},"sourceType":"script"}